# ROADMAP (план работ и контроль прогресса)

Документ создан, чтобы удобно вести разработку проекта с помощью LLM:
- дробим работу на маленькие задачи;
- у каждой задачи есть критерии готовности;
- изменения делаются итерациями, каждая итерация даёт “работающий кусок”.

## Правила работы (ритуал)
- **Одна итерация = один сквозной результат**, который можно руками проверить (пусть и с моками).
- **Маленькие изменения**: предпочтительнее несколько небольших шагов, чем один гигантский.
- **Концепции (`01–07`) меняем редко** и только осознанно.
- **Tests-first по умолчанию (не догма)**:
  - для детерминированной бизнес-логики (нормализация, сегментация/валидации, идемпотентность, инвалидация, статусы) — по возможности начинать с тестов;
  - для API — минимум smoke/контрактных тестов (права, статусы, схемы);
  - для UI/админских шаблонов и внешних AI API — допускаются исключения: вместо строгого TDD использовать моки/фикстуры и проверяемые инварианты.
- **Каждая задача** должна описывать:
  - цель,
  - вход/выход,
  - критерии готовности,
  - как проверить (команды/проверки).

## Учёт задач: статусы, приёмка и “защита от дурака”

### Статус задачи
Каждая задача в этом документе помечается чекбоксом:
- `[ ]` — задача **не принята** (todo / in progress / needs fixes)
- `[x]` — задача **принята** (done)

Важно: задача считается `[x]` **только после явной приёмки пользователем**, даже если LLM рапортует “всё готово”.

### Как принимать задачу (команда приёмки)
Чтобы LLM поставила галочку, используйте явную формулировку:

- **“Принимаю `<TASK_ID>`.”**

Примеры:
- “Принимаю T0.1.”
- “Принимаю T2.1, всё ок.”

### Как вернуть задачу из done обратно в todo
Если нужно снять галочку (например, решили переделать), используйте:

- **“Верни `<TASK_ID>` в todo (сними галочку).”**

### Повторное выполнение уже выполненной задачи (защита от дурака)
Если вы просите: “Делай `<TASK_ID>`”, а она отмечена как `[x]`, LLM должна:
- **остановиться**, предупредить, что задача уже принята;
- спросить одно из:
  - “Снять галочку и переделать?” или
  - “Задача принята — не трогаем, уточните что именно нужно изменить?”

Без явного подтверждения LLM не должна молча “переделывать” принятые задачи.

## Эпики (высокоуровнево)
- **E0. Foundation**: каркас проекта, окружение, линтеры/форматтеры, базовый CI.
- **E1. Content Model**: модели данных и базовая админка.
- **E2. Pipeline & Queue**: Celery+Redis, статусы, идемпотентность, ретраи.
- **E3. MVP Import/Structure**: импорт `.txt`, нормализация, базовая структура (блоки/сцены/якоря).
- **E4. MVP Assets**: мок‑генерация изображений → ревью → публикация.
- **E5. Reader UI**: читалка с клиентской пагинацией и якорями.
- **E6. Real AI Provider**: интеграция с реальным провайдером генерации изображений.
- **E7. Hardening**: права доступа, лимиты/бюджеты, наблюдаемость, оптимизация.

## Итерации (предлагаемая последовательность)

### I0 — Каркас проекта (минимально запускается)
**Цель**: иметь репозиторий, который можно поднять и развивать без хаоса.

- [ ] **T0.1** Инициализация backend-проекта (Django) и базовых настроек
  - **DoD**: проект стартует, есть settings для dev, секреты не коммитятся.
- [ ] **T0.2** docker-compose для dev: Postgres + Redis + SeaweedFS (S3)
  - **DoD**: сервисы стартуют, Django подключается к Postgres, может писать в S3-compatible хранилище (SeaweedFS) (пока хотя бы тестом).
- [ ] **T0.3** Базовые инструменты качества: форматтер/линтер + pre-commit
  - **DoD**: один командный entrypoint “lint” проходит локально.

### I1 — Контентная модель + админка CRUD
**Цель**: описать ядро данных и увидеть его в Django Admin.

- [ ] **T1.1** Модели: Story, StoryVersion, Block, Scene, Anchor
  - **DoD**: миграции; admin CRUD; связи и базовые индексы.
- [ ] **T1.2** Модели медиа и задач: Asset, GenerationTask
  - **DoD**: статусная модель; хранение параметров генерации; простая админка.
- [ ] **T1.3** Политика версий (минимальная реализация)
  - **DoD**: опубликованная версия фиксируется; черновик/новая версия не ломают опубликованную.

### I2 — Очередь и “пустой” пайплайн
**Цель**: фоновые задачи работают и меняют статусы, без внешних AI.

- [ ] **T2.1** Подключить Celery и worker
  - **DoD**: задача “ping” выполняется воркером; worker видит Django models.
- [ ] **T2.2** Реализовать постановку цепочки задач на StoryVersion
  - **DoD**: IMPORT→NORMALIZE→STRUCTURE создаёт записи статусов; ошибки видны в админке.
- [ ] **T2.3** Идемпотентность на уровне задач
  - **DoD**: повторный запуск не плодит дубликаты задач/ассетов.

### I3 — MVP импорт `.txt` → структура (без AI или с минимальным AI)
**Цель**: получить сцены/якоря по загруженному тексту.

- [ ] **T3.1** Импорт `.txt` (файл) в StoryVersion
  - **DoD**: raw + normalized сохраняются; видны в админке.
- [ ] **T3.2** Нормализация текста (правила)
  - **DoD**: единые кавычки/тире/пробелы; минимум мусора.
- [ ] **T3.3** Структурирование: блоки + примитивные сцены/якоря
  - **DoD**: блоки (абзацы) создаются; сцены/якоря создаются по пресету (пусть эвристически).

### I4 — Мок-генерация изображений + Review view в админке
**Цель**: закрыть сквозной менеджерский цикл без реального провайдера.

- [ ] **T4.1** Мок‑провайдер генерации (генерит “заглушки”)
  - **DoD**: для каждой сцены создаётся Asset и отмечается готовым.
- [ ] **T4.2** Admin Review view (список сцен + картинки + кнопки)
  - **DoD**: regenerate/approve работают; статусы отображаются; есть предпросмотр.
- [ ] **T4.3** Публикация версии
  - **DoD**: published версия доступна читательскому API (хотя бы JSON).

### I5 — Читалка (Vue) с клиентской пагинацией
**Цель**: базовый UX “книги”.

- [ ] **T5.1** Reader API (получить опубликованную версию)
  - **DoD**: отдаёт структуру + ссылки на ассеты.
- [ ] **T5.2** Vue-читалка: одна страница/разворот + перелистывание
  - **DoD**: phone/tablet переключатели; якоря вставляют иллюстрации около смысла.

### I6 — Реальный AI провайдер изображений
**Цель**: заменить мок на реальную интеграцию и не сломать модель.

- [ ] **T6.1** Абстракция провайдера + конфиг
  - **DoD**: можно переключить “mock/real” флагом.
- [ ] **T6.2** Генерация изображений + сохранение в S3/SeaweedFS
  - **DoD**: ассеты сохраняются; можно перегенерировать сцену; логируются параметры.

### I7 — Укрепление (после появления ценности)
- права/роли, лимиты/бюджеты, наблюдаемость, оптимизация.

## Блок “как давать задачи LLM”
### Дефолтная команда (для короткого управления разработкой)
Используйте эту строку как “протокол по умолчанию”:

> **Делай `<TASK_ID>` по `docs/ROADMAP.md`, соблюдай `docs/DECISIONS.md` и концепции `docs/01–07`, tests-first где уместно, не расширяй scope, обновляй документацию только при необходимости, по итогам дай команды проверки и краткий итог. Если `<TASK_ID>` отмечена как `[x]`, остановись и попроси меня снять галочку или подтвердить, что нужно переделать.**

Примеры:
- “Делай **T0.1** по `docs/ROADMAP.md`, соблюдай `docs/DECISIONS.md` и концепции `docs/01–07`, tests-first где уместно, не расширяй scope, обновляй документацию только при необходимости, по итогам дай команды проверки и краткий итог.”
- “Делай **T2.1** …”

### Расширенный шаблон (когда задача неоднозначная)
Если задача может трактоваться широко, добавьте 1–3 уточнения:
- **Ограничения** (что точно не делать): “без фронта”, “без реального AI”, “без URL-импорта”.
- **Предпочтения** (как делать): “всё в docker”, “Django на хосте”, “polling вместо websockets”.
- **Проверка** (что обязательно запустить): “lint + тесты + поднять сервисы”.

Рекомендуемый формат задачи:
- **Цель** (1–2 предложения)
- **Затрагиваемые компоненты/файлы**
- **Ограничения**
- **Acceptance Criteria**
- **Как проверить** (команды)
- **DoD** (код + миграции/тесты + обновлённая документация при необходимости)

